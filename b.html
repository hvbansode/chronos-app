<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="theme-color" content="#050505">
    <title>Chronos 38.0 | Fixed Hub</title>
    <script src="https://unpkg.com/lucide@latest"></script>
    <style>
        :root {
            --bg: #050505;
            --glass: rgba(25, 25, 30, 0.9);
            --border: rgba(255, 255, 255, 0.12);
            --txt: #ffffff;
            --txt-dim: #666;
            --accent: #6366f1;
            --danger: #ef4444;
            --font: -apple-system, BlinkMacSystemFont, "Inter", "Segoe UI", monospace;
            --safe-bottom: env(safe-area-inset-bottom, 20px);
        }

        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; outline: none; user-select: none; }
        
        body {
            margin: 0; background: var(--bg); color: var(--txt);
            font-family: var(--font); height: 100dvh; width: 100vw;
            overflow: hidden; display: flex; flex-direction: column;
            cursor: default;
        }

        /* Noise Texture */
        body::before {
            content: ""; position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.8' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)' opacity='0.03'/%3E%3C/svg%3E");
            pointer-events: none; z-index: -1;
        }

        .app { position: relative; width: 100%; height: 100%; display: flex; flex-direction: column; }
        
        .stage { 
            flex: 1; display: flex; justify-content: center; align-items: center; 
            position: relative; touch-action: none; 
            transition: transform 0.4s cubic-bezier(0.2, 0.8, 0.2, 1);
        }
        .stage.shift { transform: translateY(-15%) scale(0.95); opacity: 0.5; filter: blur(2px); }

        svg#chronos {
            width: min(90vw, 550px); height: min(90vw, 550px);
            overflow: visible; transform: translateZ(0);
            filter: drop-shadow(0 40px 80px rgba(0,0,0,0.8));
        }

        /* TRACKS */
        .track { fill: none; stroke: #0e0e0e; stroke-width: 42; filter: drop-shadow(inset 0 0 10px #000); }
        .tick { stroke: #333; stroke-width: 1; opacity: 0.3; transition: stroke 0.1s; }
        .tick.major { stroke: #555; stroke-width: 1.5; opacity: 0.6; }
        .tick.cardinal { stroke: #888; stroke-width: 2; opacity: 1; }
        .tick.active { stroke: #fff; stroke-width: 3; opacity: 1; filter: drop-shadow(0 0 5px white); }

        .lbl { fill: var(--txt-dim); font-size: 10px; font-weight: 700; text-anchor: middle; dominant-baseline: central; pointer-events: none; opacity: 0.8; font-family: sans-serif; }

        /* TASKS */
        .task-grp { cursor: pointer; transition: opacity 0.3s; }
        .stage.has-sel .task-grp:not(.sel) { opacity: 0.15; filter: grayscale(1); }
        .task-path { fill: none; stroke-linecap: butt; stroke-width: 34; transition: stroke-width 0.2s cubic-bezier(0.34, 1.56, 0.64, 1); }
        .task-grp.sel .task-path { stroke-width: 44; filter: drop-shadow(0 0 15px currentColor); z-index: 10; }
        .task-grp.collision .task-path { stroke: var(--danger) !important; opacity: 0.5; }
        .task-txt { font-size: 10px; font-weight: 800; text-transform: uppercase; letter-spacing: 1px; pointer-events: none; opacity: 0; transition: opacity 0.2s; text-shadow: 0 1px 3px rgba(0,0,0,0.5); font-family: sans-serif; }
        .task-grp.show-txt .task-txt { opacity: 1; }
        .task-hit { fill: none; stroke: transparent; stroke-width: 60; cursor: pointer; }
        .h-vis { fill: var(--bg); stroke: #fff; stroke-width: 3; r: 0; pointer-events: none; transition: r 0.3s; filter: drop-shadow(0 2px 4px #000); }
        .h-hit { fill: transparent; r: 35; cursor: grab; }
        .task-grp.sel .h-vis { r: 7; }

        /* HUB RINGS */
        .hub-grp { pointer-events: none; }
        .hub-prog-bg { fill: none; stroke: #1a1a1a; stroke-width: 5; }
        /* Fixed: transform-box ensures rotation happens around the element center */
        .hub-prog-fg { 
            fill: none; stroke: var(--accent); stroke-width: 5; stroke-linecap: round; 
            transform-box: fill-box; transform-origin: center; transform: rotate(-90deg);
            transition: stroke-dashoffset 0.5s linear, stroke 0.3s; 
        }

        /* HUB TEXT */
        .hub-clock-time { font-size: 52px; font-weight: 800; fill: #fff; text-anchor: middle; letter-spacing: -3px; transition: opacity 0.3s; font-variant-numeric: tabular-nums; }
        .hub-clock-date { font-size: 12px; font-weight: 600; fill: #444; text-anchor: middle; letter-spacing: 3px; transition: opacity 0.3s; font-family: sans-serif; }
        .hub-label { font-size: 10px; font-weight: 700; fill: #666; text-anchor: middle; letter-spacing: 2px; opacity: 0; transition: opacity 0.3s; font-family: sans-serif; }
        .hub-name { font-size: 16px; font-weight: 700; fill: #fff; text-anchor: middle; opacity: 0; transition: opacity 0.3s; font-family: sans-serif; }
        .hub-count { font-size: 42px; font-weight: 800; fill: #fff; text-anchor: middle; letter-spacing: -2px; opacity: 0; transition: opacity 0.3s; font-variant-numeric: tabular-nums; }
        .hub-abs { font-size: 12px; font-weight: 600; fill: #444; text-anchor: middle; letter-spacing: 1px; opacity: 0; transition: opacity 0.3s; }
        
        .hub-grp.active .hub-clock-time, .hub-grp.active .hub-clock-date { opacity: 0; }
        .hub-grp.active .hub-label, .hub-grp.active .hub-name, .hub-grp.active .hub-count, .hub-grp.active .hub-abs { opacity: 1; }

        /* NEEDLE */
        .needle { stroke: var(--danger); stroke-width: 2; stroke-linecap: round; pointer-events: none; filter: drop-shadow(0 0 4px rgba(255, 0, 0, 0.5)); mix-blend-mode: hard-light; }
        .needle-cap { fill: var(--bg); stroke: var(--danger); stroke-width: 2; }

        /* UI ELEMENTS */
        .ghost { stroke: rgba(255,255,255,0.15); stroke-width: 34; stroke-dasharray: 0; fill: none; pointer-events: none; }
        .snap-line { stroke: var(--accent); stroke-width: 1; stroke-dasharray: 2 4; opacity: 0; pointer-events: none; transition: opacity 0.1s; }
        .snap-line.show { opacity: 1; }
        .bubble {
            position: fixed; top: 0; left: 0; pointer-events: none; z-index: 200;
            background: rgba(255,255,255,0.95); color: #000; padding: 6px 14px; border-radius: 30px; font-size: 12px; font-weight: 800;
            transform: translate(-50%, -100px) scale(0.8); opacity: 0; transition: all 0.1s;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3); display: flex; gap: 8px; align-items: center; font-family: sans-serif; font-variant-numeric: tabular-nums;
        }
        .bubble.show { opacity: 1; transform: translate(-50%, -110px) scale(1); }
        .bubble.magnet { background: var(--accent); color: white; }
        .bubble.err { background: var(--danger); color: white; }

        /* MENUS */
        .c-menu {
            position: fixed; top: 0; left: 0; z-index: 300; display: flex; gap: 12px; pointer-events: none; opacity: 0;
            transform: translate(-50%, -50%) scale(0.8); transition: all 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        .c-menu.show { opacity: 1; pointer-events: auto; transform: translate(-50%, -50%) scale(1); }
        .c-btn { width: 44px; height: 44px; border-radius: 50%; border: 1px solid rgba(255,255,255,0.1); background: rgba(30,30,35,0.95); color: white; cursor: pointer; display: flex; align-items: center; justify-content: center; box-shadow: 0 10px 20px rgba(0,0,0,0.5); transition: transform 0.2s; }
        .c-btn:hover { transform: scale(1.15); background: white; color: black; }
        .c-btn.del:hover { background: var(--danger); color: white; }

        .sheet {
            position: fixed; bottom: 0; left: 0; width: 100%;
            background: var(--glass); backdrop-filter: blur(40px) saturate(150%);
            border-top: 1px solid var(--border); border-radius: 32px 32px 0 0;
            padding: 32px; padding-bottom: calc(24px + var(--safe-bottom));
            transform: translateY(110%); transition: transform 0.4s;
            z-index: 150; display: flex; flex-direction: column; gap: 20px;
            box-shadow: 0 -30px 80px rgba(0,0,0,0.9);
        }
        .sheet.open { transform: translateY(0); }
        .sheet-head { display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px; }
        .sheet-title { font-size: 13px; font-weight: 800; color: var(--txt); letter-spacing: 1px; font-family: sans-serif; }
        input { width: 100%; background: rgba(255,255,255,0.03); border: 1px solid var(--border); color: white; padding: 16px; border-radius: 16px; font-size: 16px; font-family: inherit; transition: 0.3s; appearance: none; font-variant-numeric: tabular-nums; }
        input:focus { border-color: var(--accent); background: rgba(255,255,255,0.07); }
        .palette { display: flex; gap: 16px; overflow-x: auto; padding: 8px 0; }
        .swatch { flex: 0 0 44px; height: 44px; border-radius: 50%; border: 2px solid rgba(255,255,255,0.1); cursor: pointer; transition: all 0.3s; }
        .swatch.active { border-color: white; transform: scale(1.2); box-shadow: 0 0 20px currentColor; }
        .btn-del { width: 100%; padding: 18px; border-radius: 16px; border: none; font-size: 16px; font-weight: 700; background: rgba(239, 68, 68, 0.15); color: var(--danger); cursor: pointer; }
        .btn-del:active { transform: scale(0.98); }
    </style>
</head>
<body oncontextmenu="return false;">

<div class="app">
    <div class="stage" id="stage">
        <svg id="chronos" viewBox="0 0 600 600">
            <defs>
                <filter id="glow"><feGaussianBlur stdDeviation="3" result="coloredBlur"/><feMerge><feMergeNode in="coloredBlur"/><feMergeNode in="SourceGraphic"/></feMerge></filter>
            </defs>
            <g id="face">
                <circle cx="300" cy="300" r="220" class="track"/>
                <g id="ticks"></g>
            </g>
            
            <g id="hub" class="hub-grp" transform="translate(300, 300)">
                <circle r="140" class="hub-prog-bg" />
                <circle r="140" id="hub-progress" class="hub-prog-fg" stroke-dasharray="880" stroke-dashoffset="880" />
                <text y="15" class="hub-clock-time" id="clock-time">12:00</text>
                <text y="40" class="hub-clock-date" id="clock-date">TODAY</text>
                <text y="-40" class="hub-label-top">NOW</text>
                <text y="-15" class="hub-name" id="focus-name">Meeting</text>
                <text y="35" class="hub-count" id="focus-count">00:15:00</text>
                <text y="60" class="hub-abs" id="focus-abs">12:30</text>
            </g>

            <g id="tasks"></g>
            <g id="ui" style="pointer-events: none;">
                <path id="ghost" class="ghost" d=""></path>
                <line id="snap-line" class="snap-line" x1="300" y1="300" x2="300" y2="80" />
                <g id="needle">
                    <line x1="300" y1="300" x2="300" y2="85" class="needle"/>
                    <circle cx="300" cy="300" r="4" class="needle-cap"/>
                </g>
            </g>
        </svg>
    </div>
</div>

<div id="bubble" class="bubble"><div id="bub-val">12:00</div><span id="bub-msg"></span></div>

<div id="c-menu" class="c-menu">
    <button class="c-btn" onclick="ctrl.duplicate()"><i data-lucide="copy" size="18"></i></button>
    <button class="c-btn" onclick="ui.open()"><i data-lucide="edit-3" size="18"></i></button>
    <button class="c-btn del" onclick="ctrl.delete()"><i data-lucide="trash-2" size="18"></i></button>
</div>

<div id="sheet" class="sheet">
    <div class="sheet-head">
        <span class="sheet-title">EDIT EVENT</span>
        <i data-lucide="x" onclick="ui.close()" style="color:#fff; cursor:pointer;"></i>
    </div>
    <input type="text" id="inp-title" placeholder="Event Name">
    <div style="display:grid; grid-template-columns:1fr 1fr; gap:16px;">
        <input type="time" id="inp-start">
        <input type="time" id="inp-end">
    </div>
    <div class="palette" id="palette"></div>
    <button class="btn-del" id="btn-del"><i data-lucide="trash-2" size="20"></i> Delete Event</button>
</div>

<script>
    const CFG = { cx: 300, cy: 300, r: 220, snap: 5, magnet: 10, deadZone: 30, dragThresh: 10 };

    class Geo {
        static minToDeg(m) { return (m/1440)*360; }
        static xyToMin(x, y, svg) {
            const pt = svg.createSVGPoint(); pt.x = x; pt.y = y;
            const p = pt.matrixTransform(svg.getScreenCTM().inverse());
            const dx = p.x - CFG.cx, dy = p.y - CFG.cy;
            if(Math.sqrt(dx*dx + dy*dy) < CFG.deadZone) return null;
            let deg = (Math.atan2(dy, dx) * 180 / Math.PI) + 90;
            if(deg < 0) deg += 360;
            return Math.round((deg/360)*1440);
        }
        static polar(r, m) {
            const rad = (this.minToDeg(m) - 90) * (Math.PI/180);
            return { x: Number((CFG.cx + (r*Math.cos(rad))).toFixed(2)), y: Number((CFG.cy + (r*Math.sin(rad))).toFixed(2)) };
        }
        static arc(r, start, dur) {
            if(dur <= 0) return "";
            if(dur >= 1439) {
                const p1 = this.polar(r, 0), p2 = this.polar(r, 720);
                return `M ${p1.x} ${p1.y} A ${r} ${r} 0 0 1 ${p2.x} ${p2.y} A ${r} ${r} 0 0 1 ${p1.x} ${p1.y}`;
            }
            const s = this.polar(r, start), e = this.polar(r, start + dur);
            const large = dur > 720 ? 1 : 0;
            return `M ${s.x} ${s.y} A ${r} ${r} 0 ${large} 1 ${e.x} ${e.y}`;
        }
        static textPath(r, start, dur) {
            const mid = (start + dur/2) % 1440; const isSouth = (mid > 360 && mid < 1080);
            const s = this.polar(r, start), e = this.polar(r, start + dur);
            const large = dur > 720 ? 1 : 0;
            return `M ${isSouth?e.x:s.x} ${isSouth?e.y:s.y} A ${r} ${r} 0 ${large} ${isSouth?0:1} ${isSouth?s.x:e.x} ${isSouth?s.y:e.y}`;
        }
        static fmt(m) { m = m % 1440; if(m<0) m+=1440; return `${String(Math.floor(m/60)).padStart(2,'0')}:${String(m%60).padStart(2,'0')}`; }
        static formatCount(ms) {
            const s = Math.floor((ms / 1000) % 60); const m = Math.floor((ms / (1000 * 60)) % 60); const h = Math.floor((ms / (1000 * 60 * 60)));
            if(h>0) return `${h}:${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}`;
            return `${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}`;
        }
        static parse(s) { const [h,m] = s.split(':').map(Number); return (h*60)+m; }
        static contrast(c) {
            if(!c.startsWith('#')) return '#fff';
            const r=parseInt(c.slice(1,3),16), g=parseInt(c.slice(3,5),16), b=parseInt(c.slice(5,7),16);
            return ((r*299+g*587+b*114)/1000) > 128 ? '#000' : '#fff';
        }
    }

    class App {
        constructor() {
            this.tasks = JSON.parse(localStorage.getItem('chronos_v38')) || [];
            this.sel = null; this.editMode = false; this.subs = [];
            this.el = { 
                svg:document.getElementById('chronos'), ticks:document.getElementById('ticks'), 
                tasks:document.getElementById('tasks'), needle:document.getElementById('needle'),
                hub:document.getElementById('hub'), clockTime:document.getElementById('clock-time'), clockDate:document.getElementById('clock-date'),
                fName:document.getElementById('focus-name'), fCount:document.getElementById('focus-count'), fAbs:document.getElementById('focus-abs'),
                prog:document.getElementById('hub-progress')
            };
            this.init();
        }
        sub(fn) { this.subs.push(fn); }
        pub() { localStorage.setItem('chronos_v38', JSON.stringify(this.tasks)); this.subs.forEach(f=>f()); }
        init() {
            const f = document.createDocumentFragment();
            for(let i=0; i<96; i++) {
                const m = i*15, isH = i%4===0, isC = i%24===0;
                const p1 = Geo.polar(CFG.r+24, m), p2 = Geo.polar(CFG.r+(isH?38:28), m);
                const l = document.createElementNS("http://www.w3.org/2000/svg","line");
                l.setAttribute("x1",p1.x); l.setAttribute("y1",p1.y); l.setAttribute("x2",p2.x); l.setAttribute("y2",p2.y);
                l.setAttribute("class", `tick ${isH?'major':''} ${isC?'cardinal':''}`); l.dataset.m = m;
                f.appendChild(l);
                if(isH) {
                    const t = document.createElementNS("http://www.w3.org/2000/svg","text");
                    const lp = Geo.polar(CFG.r+55, m);
                    t.setAttribute("x",lp.x); t.setAttribute("y",lp.y); t.setAttribute("class","lbl"); t.textContent=m/60; f.appendChild(t);
                }
            }
            this.el.ticks.appendChild(f);
            
            const loop = () => {
                const now = new Date();
                const m = (now.getHours()*60)+now.getMinutes();
                this.el.needle.setAttribute("transform", `rotate(${Geo.minToDeg(m)}, 300, 300)`);
                if(!this.overrideData) this.updateHub(now, m);
                requestAnimationFrame(loop);
            };
            loop();
        }

        overrideHub(data) {
            this.overrideData = data;
            if(data) {
                this.el.hub.classList.add('active');
                this.el.fName.textContent = data.top;
                this.el.fCount.textContent = data.mid;
                this.el.fAbs.textContent = data.bot;
                this.el.fName.setAttribute("fill", "#aaa");
                this.el.fAbs.setAttribute("fill", "#aaa");
                this.el.prog.style.stroke = "#fff";
                this.el.prog.style.strokeDashoffset = 880; // During drag, ring is full or empty? Let's keep empty for simplicity
            } else {
                this.el.hub.classList.remove('active');
            }
        }

        updateHub(now, nowMins) {
            this.el.clockTime.textContent = `${String(now.getHours()).padStart(2,'0')}:${String(now.getMinutes()).padStart(2,'0')}`;
            this.el.clockDate.textContent = now.toLocaleDateString('en-US', { weekday: 'short', month: 'short', day: 'numeric' });

            let active = null;
            for(let t of this.tasks) {
                if(nowMins >= t.start && nowMins < t.start + t.duration) { active = t; break; }
                if(t.start+t.duration > 1440) { if(nowMins >= t.start || nowMins < (t.start+t.duration)%1440) { active = t; break; } }
            }

            if(active) {
                this.el.hub.classList.add('active');
                this.el.fName.textContent = active.title || "ACTIVITY";
                this.el.fName.setAttribute("fill", active.color);
                
                let remMins = (active.start + active.duration) - nowMins;
                if(remMins < 0) remMins += 1440;
                const remSecs = (remMins * 60) - now.getSeconds();
                this.el.fCount.textContent = Geo.formatCount(remSecs * 1000);
                
                // SANDCLOCK: START FULL (0), END EMPTY (880)
                const total = active.duration;
                const elapsed = total - (remSecs/60);
                const pct = Math.max(0, Math.min(1, elapsed / total));
                // Fill increases as pct increases (0 -> 880) effectively "erasing" the line if dasharray matches.
                // Correct visual for draining: Stroke is visible part. 
                // If offset is 0, full circle is visible.
                // If offset is 880, nothing is visible.
                // So as pct goes 0 -> 1, offset goes 0 -> 880.
                this.el.prog.style.strokeDashoffset = 880 * pct;
                this.el.prog.style.stroke = active.color;
            } else {
                this.el.hub.classList.remove('active');
                this.el.prog.style.strokeDashoffset = 880; // Empty
            }
        }

        getMagnet(time, excludeId) {
            let best = null, minDist = CFG.magnet;
            let gridSnap = Math.round(time/CFG.snap)*CFG.snap;
            if(Math.abs(gridSnap - time) < minDist) best = gridSnap;
            this.tasks.forEach(t => {
                if(t.id === excludeId) return;
                [t.start, t.start+t.duration].forEach(p => {
                    let d = Math.abs((p%1440) - (time%1440));
                    if(d > 720) d = 1440 - d;
                    if(d < minDist) { minDist = d; best = p; }
                });
            });
            return best;
        }
        highlightTick(m) {
            if(m === null) { Array.from(this.el.ticks.children).forEach(t => t.classList.remove('active')); return; }
            const normM = Math.round(m/15)*15 % 1440;
            Array.from(this.el.ticks.children).forEach(t => {
                if(t.tagName === 'line' && parseInt(t.dataset.m) === normM) t.classList.add('active');
                else t.classList.remove('active');
            });
        }
        isColliding(start, dur, excludeId) {
            const s1 = start, e1 = start + dur, P = 1440;
            const check = (a,b,c,d) => (a < d && b > c);
            for(let t of this.tasks) {
                if(t.id === excludeId) continue;
                let bs1 = s1 % P; if(bs1<0) bs1+=P; let be1 = bs1 + (e1-s1);
                let bs2 = t.start % P; if(bs2<0) bs2+=P; let be2 = bs2 + t.duration;
                if(check(bs1, be1, bs2, be2) || check(bs1, be1, bs2+P, be2+P) || check(bs1, be1, bs2-P, be2-P)) return t.id;
            }
            return null;
        }
        render() {
            if(this.sel && !this.tasks.find(t=>t.id===this.sel)) this.sel=null;
            this.el.tasks.innerHTML = "";
            document.getElementById('stage').classList.toggle('has-sel', !!this.sel);
            document.getElementById('stage').classList.toggle('shift', this.editMode);

            let activeEl = null;
            this.tasks.forEach(t => {
                const isSel = t.id === this.sel;
                const g = document.createElementNS("http://www.w3.org/2000/svg","g");
                g.setAttribute("class", `task-grp ${isSel?'sel':''}`); g.dataset.id=t.id;
                g.ondblclick = (e) => { e.stopPropagation(); ui.open(); };

                const hit = document.createElementNS("http://www.w3.org/2000/svg","path");
                hit.setAttribute("d", Geo.arc(CFG.r, t.start, t.duration)); hit.setAttribute("class", "task-hit"); g.appendChild(hit);

                const vis = document.createElementNS("http://www.w3.org/2000/svg","path");
                vis.setAttribute("d", Geo.arc(CFG.r, t.start, t.duration)); vis.setAttribute("stroke", t.color); vis.setAttribute("class", "task-path"); g.appendChild(vis);

                if(t.duration>45) {
                    const pid=`p-${t.id}`; const defs=document.createElementNS("http://www.w3.org/2000/svg","defs");
                    const dp=document.createElementNS("http://www.w3.org/2000/svg","path"); dp.setAttribute("id",pid); dp.setAttribute("d",Geo.textPath(CFG.r, t.start, t.duration)); defs.appendChild(dp); g.appendChild(defs);
                    const txt=document.createElementNS("http://www.w3.org/2000/svg","text"); txt.setAttribute("class","task-txt"); txt.setAttribute("fill", Geo.contrast(t.color)); txt.setAttribute("dy","5");
                    const tp=document.createElementNS("http://www.w3.org/2000/svg","textPath"); tp.setAttribute("href",`#${pid}`); tp.setAttribute("startOffset","50%"); tp.setAttribute("text-anchor","middle"); tp.textContent=t.title; txt.appendChild(tp); g.appendChild(txt);
                    setTimeout(()=>g.classList.add('show-txt'), 50);
                }
                if(isSel) {
                    const mkH = (m, type) => {
                        const p = Geo.polar(CFG.r, m); const grp = document.createElementNS("http://www.w3.org/2000/svg","g");
                        const v = document.createElementNS("http://www.w3.org/2000/svg","circle"); v.setAttribute("cx",p.x); v.setAttribute("cy",p.y); v.setAttribute("class",`h-vis ${type}`);
                        const h = document.createElementNS("http://www.w3.org/2000/svg","circle"); h.setAttribute("cx",p.x); h.setAttribute("cy",p.y); h.setAttribute("class","h-hit"); h.dataset.type=type; grp.append(v, h); return grp;
                    };
                    if(t.duration>15) g.appendChild(mkH(t.start, 'start')); g.appendChild(mkH(t.start+t.duration, 'end'));
                }
                if(isSel) activeEl=g; else this.el.tasks.appendChild(g);
            });
            if(activeEl) this.el.tasks.appendChild(activeEl);
        }
    }
    class Ctrl {
        constructor(app, ui) {
            this.app = app; this.ui = ui; this.mode='IDLE'; this.drag={};
            this.el = { ghost:document.getElementById('ghost'), bubble:document.getElementById('bubble'), bVal:document.getElementById('bub-val'), bMsg:document.getElementById('bub-msg'), snapLine:document.getElementById('snap-line'), cMenu:document.getElementById('c-menu') };
            this.longPressTimer = null; this.bind();
        }
        feed(e, m, msg='', err=false, show=true, magnet=false) {
            if(!show) { this.el.bubble.classList.remove('show'); this.el.snapLine.classList.remove('show'); this.app.highlightTick(null); return; }
            this.el.bubble.style.transform = `translate(${e.clientX}px, ${e.clientY-110}px) translate(-50%, 0)`;
            this.el.bVal.textContent = Geo.fmt(m); this.el.bMsg.textContent = msg; this.el.bubble.className = `bubble show ${err?'err':''} ${magnet?'magnet':''}`;
            if(magnet) { this.app.highlightTick(m); const p = Geo.polar(CFG.r+20, m); this.el.snapLine.setAttribute("x2", p.x); this.el.snapLine.setAttribute("y2", p.y); this.el.snapLine.classList.add('show'); } 
            else { this.el.snapLine.classList.remove('show'); this.app.highlightTick(null); }
        }
        showContext(e) {
            e.preventDefault(); if(!this.app.sel) return;
            let x = e.clientX, y = e.clientY;
            x = Math.max(60, Math.min(window.innerWidth-60, x)); y = Math.max(60, Math.min(window.innerHeight-60, y));
            this.el.cMenu.style.left = x + 'px'; this.el.cMenu.style.top = y + 'px'; this.el.cMenu.classList.add('show');
        }
        hideContext() { this.el.cMenu.classList.remove('show'); }
        duplicate() {
            const t = this.app.tasks.find(x=>x.id===this.app.sel);
            if(t) { 
                let start = t.start+t.duration+15;
                if(!this.app.isColliding(start, t.duration, null)) {
                    this.app.tasks.push({ id:Date.now().toString(), title:t.title+' Copy', start:start, duration:t.duration, color:t.color }); 
                    this.app.sel = this.app.tasks[this.app.tasks.length-1].id; this.app.pub(); this.app.render();
                }
            } this.hideContext();
        }
        delete() { this.app.tasks = this.app.tasks.filter(x=>x.id!==this.app.sel); this.ui.deselect(); this.hideContext(); }
        warn(id) { const el = document.querySelector(`.task-grp[data-id="${id}"]`); if(el) { el.classList.add('collision'); setTimeout(()=>el.classList.remove('collision'), 200); } }
        bind() {
            const svg = this.app.el.svg;
            window.addEventListener('keydown', (e) => { 
                if(this.app.sel && (e.key==='Delete'||e.key==='Backspace')) { this.delete(); }
                if(e.key==='Escape') { this.ui.close(); } 
            });
            window.addEventListener('pointerdown', (e) => {
                if(!e.target.closest('.c-menu')) this.hideContext();
                if(e.target.closest('.sheet') || e.target.closest('.task-grp') || e.target.classList.contains('h-hit') || e.target.closest('.c-menu')) return;
                if(this.app.sel && !this.app.editMode) { this.ui.deselect(); } else if(this.app.editMode && !e.target.closest('.sheet')) { this.ui.close(); }
            });
            window.addEventListener('pointerup', () => { 
                this.mode='IDLE'; 
                this.el.ghost.setAttribute("d",""); 
                this.feed(null,0,'',false,false); 
                this.app.overrideData = null;
                clearTimeout(this.longPressTimer); 
            });

            svg.addEventListener('pointerdown', (e) => {
                if(e.target.closest('.sheet')) return;
                const m = Geo.xyToMin(e.clientX, e.clientY, svg); if(m===null) return; const t = e.target;
                
                // Long press for context
                this.longPressTimer = setTimeout(() => { 
                    if(this.mode !== 'IDLE') return; 
                    if(t.closest('.task-grp')) { 
                        this.app.sel = t.closest('.task-grp').dataset.id; 
                        this.app.pub(); this.app.render(); 
                        this.showContext(e); 
                    } 
                }, 600);

                if(t.classList.contains('h-hit')) { 
                    const task = this.app.tasks.find(x=>x.id===this.app.sel); 
                    this.mode='RESIZE'; this.drag={ type:t.dataset.type, lastM:m, task:task, accDur: task.duration, originalS: task.start, originalD: task.duration }; 
                    svg.setPointerCapture(e.pointerId); return; 
                }
                
                const grp = t.closest('.task-grp');
                if(grp) { 
                    const id = grp.dataset.id; const now = Date.now(); 
                    if(this.app.sel === id && (now - this.lastTap < 300)) { this.ui.open(); this.lastTap=0; return; } 
                    this.lastTap = now; this.app.sel = id; this.app.pub(); 
                    const task = this.app.tasks.find(x=>x.id===id); 
                    this.mode='MOVE_PRE'; this.drag={ lastM:m, task:task, originalS: task.start, ox:e.clientX, oy:e.clientY }; 
                    svg.setPointerCapture(e.pointerId); return; 
                }
                
                if(!this.app.sel) { 
                    this.mode='CREATE_PRE'; const snap=Math.round(m/CFG.snap)*CFG.snap; 
                    this.drag={ startM:m, anchor:snap, ox:e.clientX, oy:e.clientY }; 
                    svg.setPointerCapture(e.pointerId); 
                }
            });

            svg.addEventListener('pointermove', (e) => {
                if(this.mode==='IDLE') return; e.preventDefault();
                const m = Geo.xyToMin(e.clientX, e.clientY, svg); if(m===null) return;
                
                if(this.mode==='MOVE_PRE' || this.mode==='CREATE_PRE') { 
                    if(Math.hypot(e.clientX-this.drag.ox, e.clientY-this.drag.oy) > CFG.dragThresh) { 
                        clearTimeout(this.longPressTimer); 
                        this.mode = this.mode === 'MOVE_PRE' ? 'MOVE' : 'CREATE'; 
                    } else return; 
                }
                
                let effM = m, isMagnet = false; const magSnap = this.app.getMagnet(m, this.app.sel); if(magSnap !== null) { effM = magSnap; isMagnet = true; }
                
                let delta = effM - this.drag.lastM; if(delta > 720) delta -= 1440; if(delta < -720) delta += 1440; this.drag.lastM = effM;
                
                if(this.mode==='MOVE') {
                    let ns = this.drag.task.start + delta; while(ns<0) ns+=1440; while(ns>=1440) ns-=1440; this.drag.task.start = ns;
                    const collision = this.app.isColliding(ns, this.drag.task.duration, this.drag.task.id);
                    if(collision) this.warn(this.drag.task.id); this.app.render(); this.feed(e, ns, collision?"COLLISION":isMagnet?"SNAP":"", collision, true, isMagnet);
                    this.app.overrideHub({ top: "MOVING", mid: Geo.fmt(ns), bot: "START TIME" });
                } else if(this.mode==='RESIZE') {
                    if(this.drag.type === 'end') this.drag.accDur += delta; else { this.drag.task.start += delta; this.drag.accDur -= delta; }
                    if(this.drag.accDur < 5) this.drag.accDur = 5; this.drag.task.duration = this.drag.accDur;
                    const collision = this.app.isColliding(this.drag.task.start, this.drag.task.duration, this.drag.task.id);
                    if(collision) this.warn(this.drag.task.id); this.app.render(); this.feed(e, this.drag.type==='end' ? this.drag.task.start+this.drag.accDur : this.drag.task.start, collision?"OVERLAP":isMagnet?"SNAP":"", collision, true, isMagnet);
                    this.app.overrideHub({ top: "RESIZING", mid: `${Math.floor(this.drag.task.duration/60)}h ${this.drag.task.duration%60}m`, bot: "DURATION" });
                } else if(this.mode==='CREATE') {
                    const snap = Math.round(m/CFG.snap)*CFG.snap; let diff = snap - this.drag.anchor; if(diff>720) diff-=1440; if(diff<-720) diff+=1440;
                    let s = this.drag.anchor, len = diff; if(len<0) { s+=len; len=Math.abs(len); } while(s<0) s+=1440; while(s>=1440) s-=1440;
                    const collision = this.app.isColliding(s, len, null); this.el.ghost.setAttribute("stroke", collision ? "var(--danger)" : "rgba(255,255,255,0.2)");
                    if(len>0) { 
                        this.el.ghost.setAttribute("d", Geo.arc(CFG.r, s, len)); 
                        this.feed(e, s+len, collision?"INVALID":"", collision); 
                        this.app.overrideHub({ top: "CREATING", mid: `${Math.floor(len/60)}h ${len%60}m`, bot: "DRAG TO SET" });
                    }
                }
            });

            svg.addEventListener('pointerup', (e) => {
                clearTimeout(this.longPressTimer);
                if(this.mode === 'MOVE' || this.mode === 'RESIZE') { const t = this.drag.task; if(this.app.isColliding(t.start, t.duration, t.id)) { t.start = this.drag.originalS; t.duration = this.drag.originalD; } else { this.app.pub(); } this.app.render(); }
                else if(this.mode==='CREATE') {
                    const m = Geo.xyToMin(e.clientX, e.clientY, svg);
                    if(m!==null) {
                        const snap = Math.round(m/CFG.snap)*CFG.snap; let diff = snap - this.drag.anchor; if(diff>720) diff-=1440; if(diff<-720) diff+=1440; let s = this.drag.anchor, len = diff; if(len<0) { s+=len; len=Math.abs(len); } while(s<0) s+=1440; while(s>=1440) s-=1440;
                        if(len>=5 && !this.app.isColliding(s, len, null)) { const cols=['#6366f1','#f43f5e','#10b981','#f59e0b','#0ea5e9','#8b5cf6']; this.app.tasks.push({ id:Date.now().toString(), title:'New Event', start:s, duration:len, color:cols[Math.floor(Math.random()*cols.length)] }); this.app.sel = this.app.tasks[this.app.tasks.length-1].id; this.app.pub(); }
                    } this.el.ghost.setAttribute("d","");
                } 
                this.mode='IDLE'; this.feed(null,0,'',false,false);
                this.app.overrideData = null;
            });
        }
    }
    class UI {
        constructor(app) { this.app = app; this.el = { sheet:document.getElementById('sheet'), title:document.getElementById('inp-title'), start:document.getElementById('inp-start'), end:document.getElementById('inp-end'), pal:document.getElementById('palette'), del:document.getElementById('btn-del') }; this.initPal(); this.bind(); }
        initPal() { ['#6366f1','#f43f5e','#10b981','#f59e0b','#0ea5e9','#8b5cf6','#ec4899','#f472b6','#ffffff'].forEach(c=>{ const d=document.createElement('div'); d.className='swatch'; d.style.background=c; d.onclick=()=>{ const t=this.app.tasks.find(x=>x.id===this.app.sel); if(t){ t.color=c; this.app.pub(); }}; this.el.pal.appendChild(d); }); }
        open() { this.app.editMode = true; this.el.sheet.classList.add('open'); const t = this.app.tasks.find(x=>x.id===this.app.sel); if(t) { this.el.title.value=t.title; this.el.start.value=Geo.fmt(t.start); this.el.end.value=Geo.fmt(t.start+t.duration); Array.from(this.el.pal.children).forEach(c=>c.classList.toggle('active', c.style.backgroundColor.includes(t.color)||t.color===c.style.backgroundColor)); } this.app.render(); }
        close() { this.app.editMode = false; this.el.sheet.classList.remove('open'); this.app.render(); }
        deselect() { this.app.sel = null; this.app.editMode = false; this.el.sheet.classList.remove('open'); this.app.pub(); }
        bind() { document.getElementById('btn-del').onclick = () => { this.app.tasks = this.app.tasks.filter(x=>x.id!==this.app.sel); this.deselect(); }; const getT=()=>this.app.tasks.find(x=>x.id===this.app.sel); this.el.title.oninput=(e)=>{ const t=getT(); if(t) t.title=e.target.value; this.app.pub(); }; this.el.start.onchange=(e)=>{ const t=getT(); if(t) { t.start=Geo.parse(e.target.value); this.app.pub(); } }; this.el.end.onchange=(e)=>{ const t=getT(); if(t) { let d=Geo.parse(e.target.value)-t.start; if(d<0) d+=1440; if(d<5) d=5; t.duration=d; this.app.pub(); } }; }
    }
    const app = new App(); const ui = new UI(app); const ctrl = new Ctrl(app, ui); app.sub(() => { app.render(); }); app.pub();
</script>
</body>
</html>